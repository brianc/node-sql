#!/usr/bin/env node

var fs = require('fs'),
  program = require('commander'),
  path = require('path'),
  async = require('async'),
  util = require('util'),
  version = '0.0.1',
  programName = path.basename(process.argv[1]);

require('colors');

function loadModule(name, errorMessage) {
  try {
    return require(name);
  } catch (e) {
    finish(errorMessage || 'Could not require module "' + name + '"');
  }
}

program
  .version(version)
  .option('-d, --dialect <dialect>', 'Specify the SQL dialect: "mysql" or "pg"')
  .option('-o, --output-file <file>', 'Output to this file; defaults to stdout')
  .option('-i, --indent <token>', 'Indentation token; defaults to a TAB character', '\t')
  .option('-s, --schema <name>', 'Name of schema to extract')
  .option('--camelize', 'Convert underscored names to camel case ("foo_bar" -> "fooBar")', false)
  .option('--eol <token>', 'Line terminator token; defaults to "\\n"', '\n')
  .option('--mode <mode>', 'The permission mode of the generated file; defaults to 0644', 0644)
  .option('--encoding <encoding>', 'The encoding to use for writing; defaults to "utf8"', 'utf8')
  .option('--prepend <text>', 'Prepend text to the beginning of the file')
  .option('--append <text>', 'Append text to the end of the file')
  .option('--dsn <dsn>', 'Connection string')
  .option('--no-comments', 'Omit autogenerated comments')
  .option('-v, --verbose', 'Print debugging information', false)
  .on('--help', function() {
    console.log('Example DSN:');
    console.log('  PostgreSQL: "tcp://postgres:1234@localhost/postgres"');
    console.log('       MySQL: "mysql://user:password@host/schema"');
  })
  .parse(process.argv);

//validate args
var dialect = (program.dialect || '').toLowerCase(),
  supportedDialects = { mysql: 1, pg: 1 };

if (!supportedDialects[dialect]) {
  finish('"--dialect" option must be one of "mysql" (MySQL) or "pg" (PostgreSQL)');
}

if (!program.dsn) {
  finish('The "--dsn" option is required');
}
if (!program.schema) {
  finish('The "--schema" option is required');
  process.exit(1);
}

var fd = program.outputFile ? fs.openSync(program.outputFile, 'w', program.mode) : 1,
  position = 0,
  programStart = Date.now();

var client = null,
  errorMessage = 'Please run "npm install %s" wherever node-sql is installed',
  db = loadModule(dialect, util.format(errorMessage, dialect)),
  createClientAndConnect;

debug('Attempting connection with DSN "' + program.dsn + '"', 'debug');

switch (dialect) {
  case 'mysql':
    createClientAndConnect = function(callback) {
      client = db.createConnection(program.dsn);
      client.connect(callback);
    };
    break;
  case 'pg':
    createClientAndConnect = function(callback) {
      client = new db.Client(program.dsn);
      client.connect(callback);
    };
    break;
}
try {
  createClientAndConnect(ready);
} catch (e) {
  finish('Error creating database client (check your DSN): ' + e);
}

function camelize(name) {
  return !program.camelize ? name : name.replace(/_(.)/g, function(all, c) {
    return c.toUpperCase();
  });
}

function runQuery(query, params, callback) {
  if (program.verbose) {
    debug('QUERY: ' + query + ' :: ' + util.inspect(params), 'sql');
  }
  switch (dialect) {
    case 'mysql':
      client.query(query, params, callback);
      break;
    case 'pg':
      client.query(query, params, function(err, result) {
        callback(err, result && result.rows);
      });
      break;
  }
}

function write() {
  var string = [].slice.call(arguments)
      .map(function(obj) { return (obj || '').toString(); })
      .filter(function(message) { return !!message; })
      .join(program.eol),
    buffer = new Buffer(string, program.encoding);

  try {
    fs.writeSync(fd, buffer, 0, buffer.length);
    position += buffer.length;
  } catch (e) {
    finish(e);
  }
}

function getListOfTables(callback) {
  var query = '';
  switch (dialect) {
    case 'mysql':
      query = 'SELECT\n' +
        'TABLE_NAME `name`\n' +
        'FROM information_schema.TABLES\n' +
        'WHERE TABLE_SCHEMA=?';
      break;
    case 'pg':
      query = 'SELECT\n' +
        'table_name "name"\n' +
        'FROM information_schema.tables\n' +
        'WHERE table_schema = \'public\'\n' +
        'AND table_catalog = $1';
      break;
  }

  runQuery(query, [ program.schema ], function(err, rows) {
    if (err) {
      callback(err);
      return;
    }

    callback(null, rows.map(function(row) {
      return row.name;
    }));
  });
}

function getListOfColumns(tableName, callback) {
  var query = '';
  switch (dialect) {
    case 'mysql':
      query = 'SELECT\n' +
        'COLUMN_NAME `name`\n' +
        'FROM information_schema.COLUMNS\n' +
        'WHERE TABLE_SCHEMA=?\n' +
        'AND TABLE_NAME=?\n' +
        'ORDER BY ORDINAL_POSITION ASC';
      break;
    case 'pg':
      query = 'SELECT\n' +
        'column_name "name" \n' +
        'FROM information_schema.columns\n' +
        'WHERE table_schema=\'public\'\n' +
        'AND table_catalog=$1\n' +
        'AND table_name=$2\n' +
        'ORDER BY ordinal_position ASC';
      break;
  }

  runQuery(query, [ program.schema, tableName ], function(err, results) {
    if (err) {
      callback(err);
      return;
    }

    callback(null, results.map(function(row) {
      return row.name;
    }));
  });
}

function debug(message, type) {
  if (!program.verbose) {
    return;
  }

  var color;
  switch (type) {
    case 'info':
      color = 'green';
      break;
    case 'sql':
      color = 'grey';
      break;
    case 'error':
      color = 'red';
      break;
    case 'yay!':
      color = 'blue';
      break;
    default:
      color = 'white';
      break;
  }

  console.error(message[color]);
}

function ready(err) {
  if (err) {
    finish(err);
  }

  debug('Starting generation against schema "' + program.schema + '"', 'info');
  if (program.prepend) {
    write(program.prepend + program.eol);
  }
  if (program.comments) {
    write('// autogenerated by ' + programName + ' v' + version + ' on ' + new Date() + program.eol);
  }

  write('var sql = require(\'sql\');', program.eol);

  getListOfTables(function(err, tableNames) {
    if (err) {
      finish(err);
    }

    function writeTable(tableName, next) {
      var start = Date.now();
      debug('Starting ' + program.schema + '.' + tableName + '...', 'info');
      getListOfColumns(tableName, function(err, columnNames) {
        if (err) {
          next(err);
          return;
        }

        debug('  Found ' + columnNames.length + ' columns', 'debug');

        var lines = [];

        if (program.comments) {
          lines.push('/**');
          lines.push(' * SQL definition for ' + program.schema + '.' + tableName);
          lines.push(' */');
        }

        lines.push('exports.' + camelize(tableName) + ' = sql.define({');
        lines.push(program.indent + 'name: \'' + tableName + '\',');
        lines.push(program.indent + 'columns: [');

        lines.push(columnNames.map(function(columnName) {
          return program.indent + program.indent + '\'' + camelize(columnName) + '\'';
        }).join(',' + program.eol));

        lines.push(program.indent + ']');
        lines.push('});');
        lines.push(program.eol);

        write.apply(null, lines);
        debug('  ...finished! (' + (Date.now() - start) + 'ms)', 'debug');
        next();
      });
    }

    async.eachSeries(tableNames, writeTable, finish);
  });
}

function finish(err) {
  if (err) {
    console.error(err.toString().red);
  } else {
    write(program.append);
  }

  if (fd && fd !== 1) {
    fs.closeSync(fd);
  }

  if (!err) {
    debug(
      '\nAll done! Wrote ' + position + ' bytes to ' +
        (program.outputFile || 'stdout') + ' in ' + (Date.now() - programStart) + 'ms',
      'yay!'
    );
  }

  process.exit(err ? 1 : 0);
}
