#!/usr/bin/env node

var fs = require('fs'),
	program = require('commander'),
	path = require('path'),
	async = require('async'),
	version = '0.0.1',
	programName = path.basename(process.argv[1]);

require('colors');

program
	.version(version)
	.option('-d, --dialect <dialect>', 'Specify the SQL dialect; only supports MySQL currently', 'mysql')
	.option('-o, --output-file <file>', 'Output to this file; defaults to stdout')
	.option('-i, --indent <token>', 'Indentation token; defaults to a TAB character', '\t')
	.option('-s, --schema <name>', 'Name of schema to extract')
	.option('--eol <token>', 'Line terminator token; defaults to "\\n"', '\n')
	.option('--mode <mode>', 'The permission mode of the generated file; defaults to 0644', 0644)
	.option('--encoding <encoding>', 'The encoding to use for writing; defaults to "utf8"', 'utf8')
	.option('--prepend <text>', 'Prepend text to the beginning of the file')
	.option('--append <text>', 'Append text to the end of the file')
	.option('--dsn <dsn>', 'Connection details, e.g. "mysql://user:password@host/schema"')
	.option('--no-comments', 'Omit autogenerated comments')
	.option('-v, --verbose', 'Print debugging information', false)
	.parse(process.argv);

//validate args
var dialect = program.dialect.toLowerCase(),
	supportedDialects = { mysql: 1 };

if (!supportedDialects[dialect]) {
	console.error('Unsupported dialect: "' + dialect + '"');
	process.exit(1);
}

if (!program.dsn) {
	console.error('The "--dsn" option is required');
	process.exit(1);
}
if (!program.schema) {
	console.error('The "--schema" option is required');
	process.exit(1);
}

var fd = program.outputFile ? fs.openSync(program.outputFile, 'w', program.mode) : 1,
	position = 0,
	programStart = Date.now();

var conn = null, db;
switch (dialect) {
	case 'mysql':
		db = require('mysql');
		try {
			debug('Attempting connection with DSN "' + program.dsn + '"', 'debug');
			conn = db.createConnection(program.dsn);
			conn.connect(ready);
		} catch (e) {
			finish('Error establishing connection (check your DSN): ' + e);
		}
		break;
}

function runQuery(query, callback) {
	if (program.verbose) {
		debug('QUERY: ' + query, 'sql');
	}
	switch (dialect) {
		case 'mysql':
			conn.query(query, callback);
			break;
	}
}

function write() {
	var string = [].slice.call(arguments)
			.map(function(obj) { return (obj || '').toString(); })
			.filter(function(message) { return !!message; })
			.join(program.eol),
		buffer = new Buffer(string, program.encoding);

	try {
		fs.writeSync(fd, buffer, 0, buffer.length);
		position += buffer.length;
	} catch (e) {
		finish(e);
	}
}

function getListOfTables(callback) {
	var query = '';
	switch (dialect) {
		case 'mysql':
			query = 'SELECT \n' +
				'TABLE_NAME `name` \n' +
				'FROM information_schema.TABLES \n' +
				'WHERE TABLE_SCHEMA=' + db.escape(program.schema) + '';
			break;
	}

	runQuery(query, function(err, results) {
		if (err) {
			callback(err);
			return;
		}

		callback(null, results.map(function(row) {
			return row.name;
		}));
	});
}

function getListOfColumns(tableName, callback) {
	var query = '';
	switch (dialect) {
		case 'mysql':
			query = 'SELECT \n' +
				'COLUMN_NAME `name` \n' +
				'FROM information_schema.COLUMNS \n' +
				'WHERE TABLE_SCHEMA=' + db.escape(program.schema) + '\n' +
				'AND TABLE_NAME=' + db.escape(tableName) + '\n' +
				'ORDER BY ORDINAL_POSITION ASC';
			break;
	}

	runQuery(query, function(err, results) {
		if (err) {
			callback(err);
			return;
		}

		callback(null, results.map(function(row) {
			return row.name;
		}));
	});
}

function debug(message, type) {
	if (!program.verbose) {
		return;
	}

	var color;
	switch (type) {
		case 'info':
			color = 'green';
			break;
		case 'sql':
			color = 'grey';
			break;
		case 'error':
			color = 'red';
			break;
		case 'yay!':
			color = 'blue';
			break;
		default:
			color = 'white';
			break;
	}

	console.error(message[color]);
}

function ready(err) {
	if (err) {
		finish(err);
	}

	debug('Starting generation against schema "' + program.schema + '"', 'info');
	runQuery('USE ' + program.schema, function(err) {
		if (err) {
			finish(err);
		}

		if (program.prepend) {
			write(program.prepend + program.eol);
		}
		if (program.comments) {
			write('// autogenerated by ' + programName + ' v' + version + ' on ' + new Date());
		}

		write('var sql = require(\'sql\');', program.eol);

		getListOfTables(function(err, tableNames) {
			if (err) {
				finish(err);
			}

			function writeTable(tableName, next) {
				var start = Date.now();
				debug('Starting ' + program.schema + '.' + tableName + '...', 'info');
				getListOfColumns(tableName, function(err, columnNames) {
					if (err) {
						next(err);
						return;
					}

					debug('  Found ' + columnNames.length + ' columns', 'debug');

					var lines = [];

					if (program.comments) {
						lines.push('/**');
						lines.push(' * SQL definition for ' + program.schema + '.' + tableName);
						lines.push(' */');
					}

					lines.push('exports.' + tableName + ' = sql.define({');
					lines.push(program.indent + 'name: \'' + tableName + '\',');
					lines.push(program.indent + 'columns: [');

					lines.push(columnNames.map(function(columnName) {
						return program.indent + program.indent + '\'' + columnName + '\'';
					}).join(',' + program.eol));

					lines.push(program.indent + ']');
					lines.push('});');
					lines.push(program.eol);

					write.apply(null, lines);
					debug('  ...finished! (' + (Date.now() - start) + 'ms)', 'debug');
					next();
				});
			}

			async.eachSeries(tableNames, writeTable, finish);
		});
	});
}

function finish(err) {
	if (err) {
		console.error(err.toString().red);
	} else {
		write(program.append);
	}

	if (fd !== 1) {
		fs.closeSync(fd);
	}

	if (!err) {
		debug(
			'\nAll done! Wrote ' + position + ' bytes to ' +
				(program.outputFile || 'stdout') + ' in ' + (Date.now() - programStart) + 'ms',
			'yay!'
		);
	}

	process.exit(err ? 1 : 0);
}
